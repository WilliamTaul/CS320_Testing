
	Throughout the past weeks, I have been working on the backend for the upcoming mobile application. The three different services I delivered were the contact, task, and appointment services. After each service was completed, 
 I utilized Junit testing to ensure that they were bug-free, worked as intended, and had no issues. This project allowed me to learn a lot about the importance of testing, and how to implement testing in development. I believe these skills will assist me 
 in becoming a stronger developer moving forward. After writing the initial code for each feature, it came time to write the tests. I began by ensuring that each software requirement set was properly achieved. If requirements were not met, 
 then the customer could be dissatisfied with the product. For example, in the contact class, it was crucial that every contact had a unique ID. If two contacts could potentially share an ID it could cause a heap of trouble. The ID is a crucial part 
 of managing the different contacts. I created a Junit test to verify that two contacts could not have the same name. This was done by adding a contact to the ContactService class, and then trying to add another contact with the same ID. A flag was set where
 the test would only pass if when the duplicate ID contact was added, an “IllegalArgumentException” would be thrown. 	The quality of my Junit tests was verified when ran as “coverage as”. This allowed me to see what all parts of the written code are 
 being tested. Effective testing should cover at least 80% of the code. When performing this my tests had an overall coverage of around 85%, which exceeded the 80% I was aiming for. In turn, giving me great confidence that the code I developed would meet 
 standards. I ensured that my code was technically sound and efficient through Junit testing also. Using specific assertions for testing the different requirements allowed me to verify the expected outcomes. When creating a new task object for example, 
 the name provided for this task should be equal to the name it has. To verify this, an “assertEquals” assertion was used. However, if a null ID is provided the task should not be created. To verify that this behaves correctly an “assertThrows” assertion 
 is used. These assertions are different but are necessary and allow for testing of different situations. This is just a small example, and many different assertions were used throughout the testing process. Making efficient Junit tests requires writing 
 readable and maintainable code. As the program advances in development, the testing processes might change. If the testing code is not written well, it may not allow for easy updates. It is also crucial to not repeat tests as there is no reason to. 
I employed various testing techniques to ensure thorough code validation, including unit testing, boundary value testing, negative testing, and exception testing. Unit testing involves testing individual functions, breaking the code into small components 
to ensure each part behaves as expected. This approach helps catch bugs early. Boundary value testing, a black-box technique, examines the edges of valid and invalid input ranges since boundary values are prone to errors. For instance, if an ID length must
be 10 or fewer characters, an incorrectly implemented check might allow an invalid length. Negative testing helps reveal bugs by testing the system's response to invalid inputs, like passing a null value to a required parameter. Exception testing ensures 
that, in cases like this, the program throws appropriate exceptions. Together, these techniques achieve broad test coverage and help ensure code reliability. I did not utilize other testing techniques, such as security testing, stress testing, 
and user acceptance testing. These are essential in different contexts. Security testing, for example, uncovers vulnerabilities that could allow malicious attacks. Stress testing puts the software under extreme load, essential in mission-critical applications
like aircraft systems, where failure can have severe consequences. Finally, user acceptance testing involves real end-users verifying the software meets their expectations, typically the last phase before release. Although I didn’t use these techniques in
my project, I recognize their value. While working on this project I adopted the mindset of achieving the customers’ goals with as minimal friction as possible. I want to deliver quality content as that is what will benefit the customer and myself the greatest. In acting as a software tester, caution must be heeded. It is very important to see the whole picture of the project and how each aspect interacts with another. In the program, an appointment is a specific object that holds values specific to that very important. It has an ID which makes it easily manageable and accessible in the database, a date that the user can see and interpret, and a description which allows the user to know what the appointment is about. There can be many appointments, so a separate class handles the logic of handling all the different appointments. If it is not understood how these two different objects interact with one another, then crucial mistakes could be made. If you were to associate a customer ID with the AppointmentService object for example, tests may be able to pass that were not supposed to pass. 
Discipline is another crucial aspect of software testing. Without proper discipline corners can be cut that will end up costing the customer, and in turn losing trust in you as a developer. One aspect of discipline is limiting the bias in reviewing the code.
It is important to get in the mindset of not being arrogant about your work, and being able to properly judge it. Sometimes this can be difficult when hours are spent developing only to realize there is a major issue causing more work. When developing a 
simple mobile application, the consequences of not being disciplined may not seem that bad. These habits will slowly start to build up though and is a disaster waiting to happen. One plan I’ve implemented into my coding to avoid technical debt is regular 
refactoring. By regularly assessing the code I have written and restructuring it in a way that makes it better, I am constantly looking for deficiencies. It also allows me to go over my work, realize how I have grown as a developer, and allow myself to reflect. 
